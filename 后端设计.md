# Podcast Manager 后端设计文档

## 架构概览

```
podcast-backend/
|-- app/
|   |-- __init__.py          # Flask应用工厂
|   |-- config.py             # 配置管理
|   |-- models/               # 数据模型
|   |   |-- __init__.py
|   |   |-- feed.py           # RSS源
|   |   |-- episode.py        # 单集
|   |   |-- transcript.py     # 转录
|   |   |-- summary.py        # 摘要
|   |   |-- task.py           # 任务记录 (新增)
|   |-- api/                  # API路由
|   |   |-- __init__.py
|   |   |-- feeds.py          # /api/feeds
|   |   |-- episodes.py       # /api/episodes
|   |   |-- transcripts.py    # /api/transcripts
|   |   |-- summaries.py      # /api/summaries
|   |   |-- tasks.py          # /api/tasks (新增)
|   |-- services/             # 业务逻辑
|   |   |-- __init__.py
|   |   |-- rss_service.py    # RSS解析
|   |   |-- audio_service.py  # 音频下载
|   |   |-- transcribe_service.py  # 转录
|   |   |-- summary_service.py     # 摘要生成
|   |   |-- task_queue.py     # 任务队列管理 (新增)
|   |-- tasks/                # 后台任务
|   |   |-- __init__.py
|   |   |-- scheduler.py      # 定时任务
|   |   |-- worker.py         # 后台worker (新增)
|-- media/                    # 媒体文件目录 (新增)
|   |-- audio/                # 音频文件
|   |-- covers/               # 封面图片
|-- run.py                    # 启动入口
|-- requirements.txt
```

---

## MongoDB 数据模型

### 1. feeds (RSS订阅源)

```javascript
{
  _id: ObjectId,
  title: "Lex Fridman Podcast",
  rss_url: "https://lexfridman.com/feed/podcast/",
  website: "https://lexfridman.com",
  image: "https://...",
  description: "...",
  author: "Lex Fridman",
  language: "en",

  // 状态管理
  status: "active",        // active | paused | error
  last_checked: ISODate,
  last_updated: ISODate,
  check_error: null,       // 最近一次错误信息

  // 用户交互
  is_starred: false,
  is_favorite: false,
  tags: ["AI", "Tech"],

  // 统计
  episode_count: 450,
  unread_count: 5,

  created_at: ISODate,
  updated_at: ISODate
}
```

### 2. episodes (单集)

```javascript
{
  _id: ObjectId,
  feed_id: ObjectId,       // 关联feed

  // 基础信息
  guid: "unique-episode-id",
  title: "Episode Title",
  description: "...",
  link: "https://...",
  published: ISODate,

  // 音频
  audio_url: "https://...",
  audio_type: "audio/mpeg",
  audio_size: 54321000,
  duration: 3600,          // 秒

  // 处理状态
  status: "new",           // new | downloaded | transcribing | transcribed | summarized | error
  audio_path: null,        // 本地音频路径

  // 用户交互
  is_read: false,
  is_starred: false,
  is_favorite: false,
  play_position: 0,        // 播放进度(秒)

  // 讨论度/热度 (后续扩展)
  popularity_score: 0,

  created_at: ISODate,
  updated_at: ISODate
}
```

### 3. transcripts (转录)

```javascript
{
  _id: ObjectId,
  episode_id: ObjectId,

  // 转录结果
  text: "Full transcript text...",
  segments: [
    { start: 0.0, end: 5.2, text: "Hello and welcome...", speaker: "A" },
    { start: 5.2, end: 10.1, text: "Today we have...", speaker: "B" }
  ],

  // AssemblyAI 扩展字段 (说话人分离模式)
  speakers: ["A", "B"],              // 检测到的说话人列表
  chapters: [                         // 自动章节 (AssemblyAI)
    {
      start: 0.0,
      end: 300.5,
      headline: "Introduction",
      summary: "The host introduces the guest..."
    }
  ],
  entities: [                         // 实体识别 (AssemblyAI)
    { text: "OpenAI", entity_type: "organization" },
    { text: "Elon Musk", entity_type: "person" }
  ],

  // 元信息
  language: "en",
  word_count: 15000,
  duration: 3600000,                  // 音频时长(毫秒)
  source: "assemblyai",               // assemblyai | whisper | official | manual
  model: "assemblyai",                // assemblyai | whisper-small | whisper-base

  created_at: ISODate,
  updated_at: ISODate
}
```

**转录来源说明:**

| source | 说明 | segments.speaker |
|--------|------|------------------|
| assemblyai | AssemblyAI云端API | 有 (A, B, C...) |
| whisper | Faster-Whisper本地 | 无 |
| official | 官方字幕抓取 | 无 |
| manual | 手动上传 | 可选 |

### 4. summaries (摘要)

```javascript
{
  _id: ObjectId,
  episode_id: ObjectId,

  // 摘要内容
  tldr: "One sentence summary",
  key_points: [
    { point: "Key point 1", timestamp: "00:05:23" },
    { point: "Key point 2", timestamp: "00:12:45" }
  ],
  why_it_matters: "Industry impact analysis...",
  tags: ["AI", "Investment", "Tech"],

  // 中文版
  tldr_zh: "一句话总结",
  key_points_zh: ["要点1", "要点2"],

  // 元信息
  model: "local-llm",      // 使用的模型

  created_at: ISODate
}
```

### 5. tasks (异步任务记录) - 新增

```javascript
{
  _id: ObjectId,
  task_id: "uuid-string",      // 唯一任务ID，返回给前端轮询用

  // 任务类型
  task_type: "download",       // download | transcribe | summarize | refresh

  // 关联资源
  episode_id: ObjectId,        // 可选，关联的episode
  feed_id: ObjectId,           // 可选，关联的feed

  // 状态管理
  status: "pending",           // pending | processing | completed | failed
  progress: 0,                 // 0-100 进度百分比
  error_message: null,

  // 时间记录
  created_at: ISODate,
  started_at: ISODate,
  completed_at: ISODate
}
```

---

## REST API 设计

### Feeds API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | /api/feeds | 获取所有订阅 |
| GET | /api/feeds/:id | 获取单个订阅详情 |
| POST | /api/feeds | 添加新订阅 |
| PUT | /api/feeds/:id | 更新订阅 |
| DELETE | /api/feeds/:id | 删除订阅 |
| POST | /api/feeds/:id/refresh | 手动刷新订阅 |
| POST | /api/feeds/:id/star | 标星 |
| POST | /api/feeds/:id/favorite | 收藏 |
| GET | /api/feeds/starred | 获取已标星 |
| GET | /api/feeds/favorites | 获取已收藏 |

### Episodes API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | /api/episodes | 获取所有单集 (支持分页/筛选) |
| GET | /api/episodes/:id | 获取单集详情 |
| GET | /api/feeds/:id/episodes | 获取某订阅的所有单集 |
| POST | /api/episodes/:id/download | 下载音频 |
| POST | /api/episodes/:id/star | 标星 |
| POST | /api/episodes/:id/favorite | 收藏 |
| PUT | /api/episodes/:id/read | 标记已读 |
| PUT | /api/episodes/:id/position | 更新播放进度 |
| GET | /api/episodes/unread | 获取未读 |
| GET | /api/episodes/starred | 获取已标星 |

### Transcripts API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | /api/episodes/:id/transcript | 获取转录 |
| POST | /api/episodes/:id/transcribe | 触发转录任务 |
| GET | /api/episodes/:id/transcribe/status | 获取转录状态 |

### Summaries API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | /api/episodes/:id/summary | 获取摘要 |
| POST | /api/episodes/:id/summarize | 触发摘要生成 |
| GET | /api/episodes/:id/summarize/status | 获取摘要状态 |

### 通用API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | /api/stats | 全局统计信息 |
| GET | /api/tags | 获取所有标签 |
| GET | /api/search?q=xxx | 全局搜索 |

### Tasks API (新增 - 异步任务)

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | /api/tasks/:task_id | 获取任务状态 |
| GET | /api/tasks | 获取所有任务列表 |
| DELETE | /api/tasks/:task_id | 取消任务 |

---

## 异步任务机制 (Critical)

### 问题

下载50MB音频、转录1小时播客，同步处理会导致：
- 浏览器 504 Gateway Timeout
- 用户以为死机

### 解决方案

**立即返回 task_id，后台处理，前端轮询状态**

### API 行为变更

```
# 原来 (同步，会超时)
POST /api/episodes/:id/download
-> 等30秒 -> 返回结果

# 现在 (异步)
POST /api/episodes/:id/download
-> 立即返回 {"task_id": "abc123", "status": "queued"}

GET /api/tasks/abc123
-> {"status": "processing", "progress": 45}

GET /api/tasks/abc123
-> {"status": "completed", "result": {...}}
```

### 实现方案 (MVP用线程池)

```python
# services/task_queue.py
from concurrent.futures import ThreadPoolExecutor
import uuid

executor = ThreadPoolExecutor(max_workers=3)
task_store = {}  # MVP用内存，后续换Redis

def submit_task(task_type: str, func, *args, **kwargs) -> str:
    task_id = str(uuid.uuid4())
    task_store[task_id] = {
        "status": "pending",
        "progress": 0,
        "result": None,
        "error": None
    }

    def wrapper():
        task_store[task_id]["status"] = "processing"
        try:
            result = func(*args, **kwargs)
            task_store[task_id]["status"] = "completed"
            task_store[task_id]["result"] = result
        except Exception as e:
            task_store[task_id]["status"] = "failed"
            task_store[task_id]["error"] = str(e)

    executor.submit(wrapper)
    return task_id

def get_task_status(task_id: str) -> dict:
    return task_store.get(task_id)
```

### 前端轮询示例

```javascript
// 前端每2秒轮询一次
async function pollTask(taskId) {
  while (true) {
    const res = await fetch(`/api/tasks/${taskId}`);
    const data = await res.json();

    if (data.status === 'completed') {
      return data.result;
    }
    if (data.status === 'failed') {
      throw new Error(data.error);
    }

    await new Promise(r => setTimeout(r, 2000));
  }
}
```

---

## 文件系统管理策略 (Critical)

### 问题

- audio_path 没有定义存在哪里
- Docker部署时容易出错

### 解决方案

```python
# config.py
import os

class Config:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))

    # 媒体文件根目录 - Docker时挂载此目录
    MEDIA_ROOT = os.getenv('MEDIA_ROOT', os.path.join(BASE_DIR, '..', 'media'))

    # 子目录
    AUDIO_DIR = os.path.join(MEDIA_ROOT, 'audio')
    COVERS_DIR = os.path.join(MEDIA_ROOT, 'covers')
    TEMP_DIR = os.path.join(MEDIA_ROOT, 'temp')

    # 确保目录存在
    @classmethod
    def init_dirs(cls):
        for d in [cls.AUDIO_DIR, cls.COVERS_DIR, cls.TEMP_DIR]:
            os.makedirs(d, exist_ok=True)
```

### 文件命名规范

```python
# 音频文件: {feed_id}/{episode_id}.mp3
audio_path = f"{AUDIO_DIR}/{feed_id}/{episode_id}.mp3"

# 封面图: {feed_id}/cover.jpg
cover_path = f"{COVERS_DIR}/{feed_id}/cover.jpg"
```

### Docker Compose 示例

```yaml
services:
  podcast-api:
    volumes:
      - ./media:/app/media  # 挂载媒体目录
    environment:
      - MEDIA_ROOT=/app/media
```

---

## 任务锁机制 (Critical)

### 问题

用户多次点击"转录"，会重复开启昂贵的AI任务

### 解决方案

**检查状态 + 拒绝重复请求**

```python
# api/transcripts.py
@app.route('/api/episodes/<id>/transcribe', methods=['POST'])
def transcribe_episode(id):
    episode = db.episodes.find_one({"_id": ObjectId(id)})

    # 检查是否已在处理中
    if episode["status"] in ["transcribing", "downloading"]:
        return jsonify({
            "success": False,
            "message": "Task already in progress",
            "error_code": "TASK_IN_PROGRESS"
        }), 409  # Conflict

    # 检查是否已完成
    if episode["status"] == "transcribed":
        return jsonify({
            "success": False,
            "message": "Already transcribed",
            "error_code": "ALREADY_COMPLETED"
        }), 409

    # 更新状态为处理中
    db.episodes.update_one(
        {"_id": ObjectId(id)},
        {"$set": {"status": "transcribing"}}
    )

    # 提交异步任务
    task_id = submit_task("transcribe", do_transcribe, id)

    return jsonify({
        "success": True,
        "data": {"task_id": task_id, "status": "queued"}
    })
```

### 状态机完整定义

```
Episode.status 状态流转:

new ─────────────────────────────────────────────────┐
 │                                                   │
 ▼                                                   │
downloading ──► downloaded ──► transcribing ──► transcribed ──► summarizing ──► summarized
 │                  │               │                                │
 ▼                  ▼               ▼                                ▼
error            error           error                            error

允许的状态转换:
- new -> downloading (开始下载)
- downloading -> downloaded (下载完成)
- downloading -> error (下载失败)
- downloaded -> transcribing (开始转录)
- transcribing -> transcribed (转录完成)
- transcribing -> error (转录失败)
- transcribed -> summarizing (开始摘要)
- summarizing -> summarized (摘要完成)
- summarizing -> error (摘要失败)
- error -> new (重试，重置状态)
```

---

## API 响应格式

### 成功响应

```json
{
  "success": true,
  "data": { ... },
  "message": null
}
```

### 列表响应 (带分页)

```json
{
  "success": true,
  "data": [ ... ],
  "pagination": {
    "page": 1,
    "per_page": 20,
    "total": 100,
    "pages": 5
  }
}
```

### 错误响应

```json
{
  "success": false,
  "data": null,
  "message": "Error description",
  "error_code": "FEED_NOT_FOUND"
}
```

---

## 最小化MVP功能清单

### Phase 1: 核心CRUD (必须)

- [x] POST /api/feeds - 添加RSS订阅
- [x] GET /api/feeds - 获取订阅列表
- [x] DELETE /api/feeds/:id - 删除订阅
- [x] POST /api/feeds/:id/refresh - 刷新获取新集
- [x] GET /api/feeds/:id/episodes - 获取单集列表
- [x] GET /api/episodes/:id - 获取单集详情

### Phase 2: 用户交互

- [ ] POST /api/feeds/:id/star - 标星
- [ ] POST /api/episodes/:id/star - 标星
- [ ] POST /api/episodes/:id/favorite - 收藏
- [ ] PUT /api/episodes/:id/read - 标记已读

### Phase 3: AI功能

- [ ] POST /api/episodes/:id/transcribe - 转录
- [ ] GET /api/episodes/:id/transcript - 获取转录
- [ ] POST /api/episodes/:id/summarize - 摘要
- [ ] GET /api/episodes/:id/summary - 获取摘要

### Phase 4: 高级功能

- [ ] GET /api/search - 搜索
- [ ] GET /api/episodes/popular - 热门内容
- [ ] 定时自动更新

---

## 扩展性设计原则

### 1. 服务层解耦

```python
# services/ 目录下每个服务独立
# 方便替换实现

class TranscribeService:
    def transcribe(self, audio_path: str) -> dict:
        # 支持多种转录后端:
        # - faster-whisper (本地)
        # - AssemblyAI API (云端，带说话人分离)
        pass

class SummaryService:
    def summarize(self, transcript: str) -> dict:
        # 当前: 本地LLM
        # 未来可换: Claude API, GPT-4, etc.
        pass
```

**转录服务选择:**

| 服务 | 适用场景 | 成本 |
|------|----------|------|
| Faster-Whisper | 单人播客、成本敏感 | 免费 |
| AssemblyAI | 多人对话、需要说话人分离 | $0.37/小时 |

### 2. 状态机设计

```
Episode状态流转:
new -> downloaded -> transcribing -> transcribed -> summarizing -> summarized
        |                |                              |
        v                v                              v
      error           error                          error
```

### 3. 异步任务支持

```python
# 预留任务队列接口
# 当前: 同步处理
# 未来: Celery / RQ / APScheduler

def transcribe_episode(episode_id: str):
    # 可以是同步调用
    # 也可以是放入任务队列
    pass
```

### 4. 配置外置

```python
# config.py
class Config:
    MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017")
    MONGO_DB = os.getenv("MONGO_DB", "podcast")

    WHISPER_MODEL = os.getenv("WHISPER_MODEL", "base")
    LLM_ENDPOINT = os.getenv("LLM_ENDPOINT", "http://localhost:11434")

    # 未来扩展
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", None)
```

---

## 给前端的接口文档模板

前端需要知道：

1. **Base URL**: `http://localhost:5000/api`
2. **认证**: 暂无 (后续可加JWT)
3. **响应格式**: JSON
4. **分页参数**: `?page=1&per_page=20`
5. **筛选参数**: `?status=active&is_starred=true`

详细接口文档可用 Swagger/OpenAPI 自动生成。

---

## 下一步

需要我现在就开始写Phase 1的代码吗？

```
Phase 1 代码量估算:
- app/__init__.py       ~30行
- app/config.py         ~20行
- app/models/feed.py    ~50行
- app/models/episode.py ~50行
- app/api/feeds.py      ~100行
- app/api/episodes.py   ~80行
- app/services/rss_service.py ~60行
- run.py                ~10行
--------------------------
总计: ~400行代码
```
